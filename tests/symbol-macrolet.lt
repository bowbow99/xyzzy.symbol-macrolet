;;; -*- mode: lisp; package: test.symbol-macrolet -*-
;;;
;;; tests/symbol-macrolet.lt
;;;

(require "lisp-unit")

(defpackage :test.symbol-macrolet
  (:use :lisp :lisp-unit))

(in-package :test.symbol-macrolet)

(eval-when (:load-toplevel :compile-toplevel :execute)
  (require "symbol-macrolet")
  (use-package :symbol-macrolet))

(remove-all-tests :test.symbol-macrolet)

(define-test symbol-macrolet
  (assert-eql 12
      (symbol-macrolet ((x 12)) x))
  (assert-eql 12
      (symbol-macrolet ((x (+ 8 4))) x))
  (assert-equal '(1 2)
      (let ((n 0))
        (symbol-macrolet ((x (incf n))) (list x x))))
  (let ((list (list 1 2 3)))
    (symbol-macrolet ((1st (first list))
                      (2nd (second list))
                      (3rd (third list)))
      (assert-equal '(1 2 3)
          (list 1st 2nd 3rd))
      (assert-eql 10
          (setf 1st 10))
      (assert-eql 20
          (setf 2nd 20))
      (assert-eql 30
          (setf 3rd 30))
      (assert-equal '(10 20 30)
          (list 1st 2nd 3rd))
      (assert-equal '(10 20 30)
          list))))

(define-test tagbody
  (assert-expands `(symbol-macrolet::progn? (tagbody start (go start)))
      (symbol-macrolet ((start (error "hey")))
        (tagbody start (go start)))))

(define-test macrolet
  (symbol-macrolet ((foo :symbol-macro))
    (macrolet ((foo (x) `(list :macrolet ,x)))
      (assert-equal '(:macrolet :symbol-macro)
          (foo foo)))
    (macrolet ((foo () `(list :macrolet foo)))
      (assert-equal '(:macrolet :symbol-macro)
          (foo)))
    (macrolet ((foo (foo) `(list :macrolet ,foo)))
      (assert-equal '(:macrolet :symbol-macro)
          (foo foo))
      (assert-equal '(:macrolet :value)
          (foo :value)))
    (macrolet ((foo () `(list :macrolet ,foo)))
      (assert-equal '(:macrolet :symbol-macro)
          (foo)))
    #|;; FIXME
    (macrolet ((foo (&optional (foo foo)) foo))
      (assert-equal ':symbol-macro (foo)))
    ;|#
    ))

(define-test shadowing-functions
  (assert-equal
      (symbol-macrolet ()
        (macrolet ((foo (x) `(list :macrolet ',x)))
          (labels ((foo (x) (list :labels x)))
            ;; function `foo' should be shadowed by `labels' and
            ;; not expanded as local-macro `foo'.
            (foo 3))))
      '(:labels 3))
  (assert-equal
      (symbol-macrolet ()
        (macrolet ((foo (x) `(list :macrolet ',x)))
          (flet   ((foo (x) (list :flet x)))
            ;; `flet' shadows `foo' as well.
            (foo 3))))
      '(:flet 3))
  (assert-equal
      (symbol-macrolet ()
        (macrolet ((foo (x) `(list :macrolet ',x)))
          (flet ((foo (x)
                   (if (zerop x) :flet (foo (1- x)))))
            ;; First, `(foo 3)' call for a function introduced by flet,
            ;; and another call for `foo' in the body of local function
            ;; should be expanded as local-macro introduced by macrolet.
            (foo 3))))
      '(:macrolet (1- x)))
  (assert-equal
      (symbol-macrolet ()
        (macrolet ((foo (x) `(list :macrolet ',x)))
          (labels ((foo (x)
                     ;; In this case, local-macro `foo' should be shadowed
                     ;; in the body of local-functions as well.  So following
                     ;; `(foo (1- x))' should be a recursion.
                     (if (zerop x) :labels (foo (1- x)))))
            (foo 3))))
      :labels))


;;; tests/symbol-macrolet.lt ends here.
